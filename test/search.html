<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">

    <style>
        /* searchdiv like spotlight */
.searchContainer {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--background-alt);
    border-radius: 10px;
    width: 80%;
    max-width: 800px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 3;

    display: none;

    transition: all 0.2s;
}

.searchContainer.active {
    display: flex;
}


.searchContainer input {
    padding: 20px;
    border: none;
    background-color: var(--background-alt);
    color: var(--text);
    font-size: 1.2rem;

    margin: auto;


    border-radius: 10px;
    display: flex;
    align-items: center;
    /* padding: 10px; */
    width: 100%;

    /* shadow */
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    transition: all 0.2s;
}

.searchContainer input:focus {
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);

}

.searchResults {
    /* below search div */
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, 0);
    background-color: var(--background-alt);
    border-radius: 10px;
    width: 100%;
    max-width: 800px;
    margin-top: 50px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    height: auto;
    transition: all 0.2s;

}

.searchResults ul {
    list-style: none;
    /* make it scrollable */
    max-height: 50vh;
    overflow-y: auto;
}

.searchResults ul li {
    padding: 10px 10px 10px 0px;
    border-bottom: 1px solid var(--background);
    color: var(--text);

    border-radius: 10px;


    /* hover effect */
    transition: all 0.2s;
}

.searchResults ul li:hover {
    padding: 10px 10px 10px 10px;
    background-color: var(--background);
}

/* last li */
.searchResults ul li:last-child {
    border-bottom: none;
}

/* dim background */
.searchBackground {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.3);
    z-index: 2;
    /* blur */
    backdrop-filter: blur(3px);
    -webkit-backdrop-filter: blur(3px);

    display: none;
}

.searchBackground.active {
    display: block;
}


/* search icon, at the bottom right */
#searchIcon {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 3;
    opacity: 1;
    transition: all 0.1s;
}

#searchOpen {
    background-color: var(--background-alt);
    color: var(--text);
    border-radius: 10px;
    padding: 13px;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    transition: all 0.2s;
}

#searchOpen:hover {
    background-color: var(--background);
}

#searchIcon.hide {
    opacity: 0;
}


    </style>
</head>
<body>

<div class="searchContainer">
    <input type="text" id="search" placeholder="Search">

    <div class="searchResults" id="searchResults">
            <p style="color: var(--text-muted); text-align: center; ">Start typing to search</p>
    </div>
</div>
<div class="searchBackground"></div>

<div id="searchIcon">
    <button id="searchOpen">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
    </button>
</div>

<div class="content">
    <page data-pageId="index" data-title="Home">

      # Tiny Docs

      ## What is Tiny Docs
      Tiny Docs is a simple and lightweight (single file!) documentation template that allows you to write documentation in markdown and have it rendered as a static site
      
      ## Features
      
      - üìÑ **Single file** - Just one HTML file!
      - üìù **Markdown** - Write documentation in [markdown](?page=snarkdown)
      - üì¶ **Zero dependencies** - No need for a build step or package manager. (Although there are tools to make it even smaller)
      - üé® **Customizable** - Change the CSS to fit your style
      - üì± **Responsive** - Works on all devices
      - üöÄ **Fast** - Loads _extremely_ fast
      
      ## Use cases
      
      - Personal documentation
      - Project documentation
      - Software documentation
      - _Anything_ that needs documentation
      I made this because I wanted a simple way to write documentation and have it in a single file. I hope you find it useful! 
      
      ## How to use
      
      > This project is still in development. Some features may not work as expected
      
      1. Download the HTML file (or clone the repo)
      1. Open the file in your text editor
      1. Write and customize your documentatio
      
      ## Planned features
      
      - [ ] üîé Search
      - [ ] ~~üìñ Table of contents~~ ‚úÖ
      - [ ] üåê Full Offline support
      - [ ] üõ†Ô∏è Import from GitHub Wiki
      - [ ] üìù (Web) Builder
      - [ ] üì§ Export to PDF/Markdown/HTML
      
    </page>
    <page data-pageId="snarkdown" data-title="Snarkdown">

      # It's powered by Snarkdown!
      [Snarkdown](https://github.com/developit/snarkdown) is a dead simple 1kb
      markdown parser that converts markdown to HTML.

      ## Example

      ## Snarkdown

![snarkdown](https://cdn.jsdelivr.net/emojione/assets/svg/1f63c.svg)

*[Snarkdown](http://github.com/developit/snarkdown)* is __easy__ to `use`!

Here's an [**important** anchor link](#example).

Two newlines creates a line break.

Or, end a line with two spaces.  
Just like that!

Code & Poetry
-------------

  You can also indent
  blocks to display
  code or poetry.
  
  Indented code/poetry blocks  
  can be hard-wrapped.

**Or, wrap your code in three backticks:**

```JavaScript
function codeBlocks() {
  return 'Can be inserted';
}
```


### Block Quotes

> You can insert quotes by
> preceeding each line with `>`.
>
> Blockquotes can also contain line  
> breaks.


## Lists

- Unordered
* Lists
+ Of mixed type

1. Ordered
2. Lists
4. Numbers are ignored

    </page>

    <page data-pageId="about"> # About
      This is the about page </page>
    <page data-pageId="404">
      # 404
      
      The page you are looking for does not exist

      [Go back to the home page](?page=index)
    </page>

    <footer>
      <p>&copy; 2024 JMcrafter26</p>
    </footer>
  </div>


  <script id="snarkdown">
  const TAGS = {
  '': ['<em>','</em>'],
  _: ['<strong>','</strong>'],
  '*': ['<strong>','</strong>'],
  '~': ['<s>','</s>'],
  '\n': ['<br />'],
  ' ': ['<br />'],
  '-': ['<hr />']
};

/** Outdent a string based on the first indented line's leading whitespace
*	@private
*/
function outdent(str) {
  return str.replace(RegExp('^'+(str.match(/^(\t| )+/) || '')[0], 'gm'), '');
}

/** Encode special attribute characters to HTML entities in a String.
*	@private
*/
function encodeAttr(str) {
  return (str+'').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

/** Parse Markdown into an HTML String. */
function parse(md, prevLinks) {
  let tokenizer = /((?:^|\n+)(?:\n---+|\* \*(?: \*)+)\n)|(?:^``` *(\w*)\n([\s\S]*?)\n```$)|((?:(?:^|\n+)(?:\t|  {2,}).+)+\n*)|((?:(?:^|\n)([>*+-]|\d+\.)\s+.*)+)|(?:!\[([^\]]*?)\]\(([^)]+?)\))|(\[)|(\](?:\(([^)]+?)\))?)|(?:(?:^|\n+)([^\s].*)\n(-{3,}|={3,})(?:\n+|$))|(?:(?:^|\n+)(#{1,6})\s*(.+)(?:\n+|$))|(?:`([^`].*?)`)|(  \n\n*|\n{2,}|__|\*\*|[_*]|~~)/gm,
      context = [],
      out = '',
      links = prevLinks || {},
      last = 0,
      chunk, prev, token, inner, t;

  function tag(token) {
      let desc = TAGS[token[1] || ''];
      let end = context[context.length-1] == token;
      if (!desc) return token;
      if (!desc[1]) return desc[0];
      if (end) context.pop();
      else context.push(token);
      return desc[end|0];
  }

  function flush() {
      let str = '';
      while (context.length) str += tag(context[context.length-1]);
      return str;
  }

  md = md.replace(/^\[(.+?)\]:\s*(.+)$/gm, (s, name, url) => {
      links[name.toLowerCase()] = url;
      return '';
  }).replace(/^\n+|\n+$/g, '');

  while ( (token=tokenizer.exec(md)) ) {
      prev = md.substring(last, token.index);
      last = tokenizer.lastIndex;
      chunk = token[0];
      if (prev.match(/[^\\](\\\\)*\\$/)) {
          // escaped
      }
      // Code/Indent blocks:
      else if (t = (token[3] || token[4])) {
          chunk = '<pre class="code '+(token[4]?'poetry':token[2].toLowerCase())+'"><code'+(token[2] ? ` class="language-${token[2].toLowerCase()}"` : '')+'>'+outdent(encodeAttr(t).replace(/^\n+|\n+$/g, ''))+'</code></pre>';
      }
      // > Quotes, -* lists:
      else if (t = token[6]) {
          if (t.match(/\./)) {
              token[5] = token[5].replace(/^\d+/gm, '');
          }
          inner = parse(outdent(token[5].replace(/^\s*[>*+.-]/gm, '')));
          if (t=='>') t = 'blockquote';
          else {
              t = t.match(/\./) ? 'ol' : 'ul';
              inner = inner.replace(/^(.*)(\n|$)/gm, '<li>$1</li>');
          }
          chunk = '<'+t+'>' + inner + '</'+t+'>';
      }
      // Images:
      else if (token[8]) {
          chunk = `<img src="${encodeAttr(token[8])}" alt="${encodeAttr(token[7])}" loading="lazy">`;
      }
      // Links:
      else if (token[10]) {
          out = out.replace('<a>', `<a href="${encodeAttr(token[11] || links[prev.toLowerCase()])}">`);
          chunk = flush() + '</a>';
      }
      else if (token[9]) {
          chunk = '<a>';
      }
      // Headings:
      else if (token[12] || token[14]) {
          t = 'h' + (token[14] ? token[14].length : (token[13]>'=' ? 1 : 2));
    console.log(token[12]);
    chunk = '<'+t+' id="'+ parse(token[12] || token[15]).replaceAll(" ","-").toLowerCase() +'" data-anchor>' + parse(token[12] || token[15], links) + '</'+t+'>';
      }
      // `code`:
      else if (token[16]) {
          chunk = '<code>'+encodeAttr(token[16])+'</code>';
      }
      // Inline formatting: *em*, **strong** & friends
      else if (token[17] || token[1]) {
          chunk = tag(token[17] || '--');
      } 
      out += prev;
      out += chunk;
  }

  return (out + md.substring(last) + flush()).replace(/^\n+|\n+$/g, '');
}

function snarkdown(md) {
return parse(md);
}
  </script>

    <script src="https://unpkg.com/quick-score@0.0.14/dist/quick-score.min.js"></script>

    <script>
        function init() {
            const pages = document.querySelectorAll("page");
            pages.forEach((page) => {
                const markdown = page.textContent.trim().replace(/^ +/gm, "");
                const htmlContent = snarkdown(markdown);
    
                // Inject IDs into the headings post-conversion
                const tempDiv = document.createElement("div");
                tempDiv.innerHTML = htmlContent;
                tempDiv.querySelectorAll("h1, h2, h3, h4, h5, h6").forEach((heading) => {
                    const id = heading.textContent.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    heading.setAttribute("id", id);
                });
                page.innerHTML = tempDiv.innerHTML;
            });
    
            const search = document.querySelector("#search");
            search.addEventListener("input", (e) => {
                const query = e.target.value;
                searchPage(query);
            });

            const searchInput = document.querySelector('#search');
    const searchContainer = document.querySelector('.searchContainer');
    const searchBackground = document.querySelector('.searchBackground');
    const searchBtn = document.getElementById('searchIcon');

            document.querySelector("#searchOpen").addEventListener("click", () => {
                searchContainer.classList.toggle('active');
                searchBackground.classList.toggle('active');
                searchInput.focus();
                searchBtn.classList.toggle('hide');
            });



    document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            searchContainer.classList.add('active');
            searchBackground.classList.add('active');
            searchInput.focus();
            searchBtn.classList.add('hide');
        }
        
        // Close with ESC
        if (e.key === 'Escape') {
            searchContainer.classList.remove('active');
            searchBackground.classList.remove('active');
            searchInput.value = '';
            searchInput.blur();
            searchBtn.classList.remove('hide');
        }
    });

    // Click outside to close
    searchBackground.addEventListener('click', () => {
        searchContainer.classList.remove('active');
        searchBackground.classList.remove('active');
        searchInput.value = '';
        searchInput.blur();
        searchBtn.classList.remove('hide');
    });
        }
    
        init();
    
        function searchPage(query) {
            
            if (!query.trim()) {
                document.getElementById('searchResults').innerHTML = '<p style="color: var(--text-muted); text-align: center; ">Start typing to search</p>';
                return;
            }
    
            const pages = document.querySelectorAll("page");
            const results = [];
    
            pages.forEach((page) => {
                const pageId = page.getAttribute('data-pageId');
                const pageTitle = page.getAttribute('data-title') || pageId;
    
                const elements = page.querySelectorAll('h1, h2, h3, h4, h5, h6, p, li');
                elements.forEach((element) => {
                    const text = element.textContent.trim();
                    if (!text) return;
    
                    const score = quickScore.quickScore(text, query);
                    if (score > 0.1) {
                        let context = element.tagName.toLowerCase().startsWith('h') 
                            ? element.textContent 
                            : findNearestHeading(element);
    
                        results.push({
                            score,
                            pageTitle,
                            pageId,
                            element,
                            context: createExcerpt(text, query),
                            heading: context
                        });
                    }
                });
            });
    
            results.sort((a, b) => b.score - a.score);
            const resultsHtml = results.map(result => `
                <li onclick="scrollToSection('${result.pageId}', '${result.heading.toLowerCase().replace(/[^a-z0-9]+/g, '-')}', '${query}')">
                    <strong>${result.pageTitle}</strong>
                    ${result.heading ? ` ‚Ä∫ ${result.heading}` : ''}
                    <div style="margin-top: 5px; font-size: 0.9em; opacity: 0.8;">
                        ${result.context}
                    </div>
                </li>
            `).join('');

            document.getElementById('searchResults').innerHTML = resultsHtml ? `<ul>${resultsHtml}</ul>` : '<p style="color: var(--text-muted); text-align: center; ">No results found</p>';
        }
    
        function scrollToSection(pageId, sectionId, query) {
            const page = document.querySelector(`page[data-pageId="${pageId}"]`);
            const section = page.querySelector(`[id="${sectionId}"]`);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                highlightText(section, query);
            }
            
            document.querySelector('.searchContainer').classList.remove('active');
            document.querySelector('.searchBackground').classList.remove('active');
            
        }
    
        function highlightText(section, query) {
            const queryTerms = query.toLowerCase().split(/\s+/);
            let innerHTML = section.cloneNode(true).innerHTML;
    
            queryTerms.forEach(term => {
                if (term.trim()) {
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    innerHTML = innerHTML.replace(
                        new RegExp(escapedTerm, 'gi'),
                        match => `<mark style="background-color: var(--accent); color: var(--text); padding: 0 2px; border-radius: 2px;">${match}</mark>`
                    );
                }
            });
    
            section.innerHTML = innerHTML;
        }
    
        function findNearestHeading(element) {
            let current = element;
            while (current) {
                let sibling = current.previousElementSibling;
                while (sibling) {
                    if (sibling.tagName.match(/^H[1-6]$/)) {
                        return sibling.textContent;
                    }
                    sibling = sibling.previousElementSibling;
                }
                current = current.parentElement;
            }
            return null;
        }
    
        function createExcerpt(text, query) {
            const words = text.split(/(\s+)/).filter(word => word.trim());
            const queryTerms = query.toLowerCase().split(/\s+/);
    
            let bestStart = 0;
            let bestEnd = Math.min(20, words.length);
            let maxQueryMatches = 0;
    
            for (let i = 0; i < words.length - 10; i++) {
                let matches = 0;
                const window = words.slice(i, i + 20).join('').toLowerCase();
                queryTerms.forEach(term => {
                    if (window.includes(term)) matches++;
                });
                
                if (matches > maxQueryMatches) {
                    maxQueryMatches = matches;
                    bestStart = i;
                    bestEnd = Math.min(i + 20, words.length);
                }
            }
    
            const excerpt = words.slice(bestStart, bestEnd).join('');
            let highlightedExcerpt = excerpt;
            
            queryTerms.forEach(term => {
                if (term.trim()) {
                    const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    highlightedExcerpt = highlightedExcerpt.replace(
                        new RegExp(escapedTerm, 'gi'),
                        match => `<mark style="background-color: var(--highlight); color: var(--button-base); padding: 0 2px; border-radius: 2px;">${match}</mark>`
                    );
                }
            });
    
            return bestStart > 0 ? `...${highlightedExcerpt}...` : `${highlightedExcerpt}...`;
        }
    </script>
    
</body>
</html>